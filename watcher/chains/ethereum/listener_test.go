package ethereum

import (
	"encoding/hex"
	"fmt"
	"io/ioutil"
	"math/big"
	"reflect"
	"testing"

	"github.com/centrifuge/go-substrate-rpc-client/v4/types"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/rlp"

	"github.com/NuLink-network/watcher/watcher/chains/substrate"
)

var (
	StakeInfo20   = make(substrate.StakeInfos, 0, 20)
	LastStakeInfo = make(map[string][32]byte)
	WantStakeInfo = make(substrate.StakeInfos, 0, 20)

	Coinbase = []types.AccountID{
		{0xd0, 0xe3, 0x83, 0x19, 0xea, 0x54, 0xa3, 0x36, 0xf8, 0x29, 0xda, 0x6c, 0xb9, 0x1e, 0x11, 0x80, 0x6c, 0x34, 0x74, 0xc3, 0x54, 0xa5, 0xc0, 0x54, 0x76, 0xb7, 0x6e, 0xa9, 0x7d, 0x6d, 0xb4, 0x14},
		{0x14, 0x82, 0x56, 0x64, 0x30, 0x71, 0xd0, 0x30, 0x55, 0xfd, 0x90, 0x82, 0x7a, 0xcd, 0x29, 0x33, 0x3b, 0x8, 0xa0, 0x44, 0xd3, 0x4b, 0x33, 0xe0, 0xc6, 0xe2, 0x5a, 0xc5, 0xfc, 0x32, 0x25, 0x4f},
		{0x24, 0x41, 0x17, 0xf0, 0x63, 0x18, 0x7a, 0x4, 0xf5, 0xe6, 0xfc, 0x92, 0xd2, 0xf2, 0xa8, 0xf5, 0xc5, 0x26, 0x2d, 0xf8, 0xd8, 0xe6, 0xa4, 0x85, 0x5, 0x9e, 0x2c, 0xe9, 0x17, 0x38, 0x81, 0x43},
		{0x54, 0xee, 0xb9, 0xe4, 0x9c, 0xf, 0x93, 0x85, 0x73, 0x57, 0x4b, 0x14, 0x49, 0x4, 0x24, 0x57, 0xdc, 0xf0, 0x9e, 0x75, 0xb0, 0x5e, 0xad, 0x42, 0x9a, 0xa4, 0x46, 0xd6, 0x9b, 0x4a, 0xff, 0x59},
		{0x94, 0xac, 0x9, 0x77, 0x77, 0x20, 0x19, 0x1d, 0x2c, 0x85, 0x9d, 0x72, 0xaf, 0x24, 0xe3, 0x72, 0x35, 0xcb, 0x4a, 0xff, 0xbc, 0x1e, 0xee, 0x57, 0xc, 0xc3, 0x8, 0x21, 0x4a, 0x75, 0x41, 0x18},
		{0x78, 0xb0, 0xd1, 0x87, 0x6e, 0xeb, 0xe, 0x17, 0x1, 0xe1, 0x1b, 0x74, 0xb5, 0xdd, 0xd5, 0xc6, 0xbf, 0xc1, 0x85, 0x2a, 0xe5, 0x5e, 0x7, 0xaa, 0xa3, 0x6a, 0x78, 0x8b, 0x10, 0xaa, 0xbb, 0x10},
		{0xd4, 0xa8, 0x3e, 0x5f, 0xbf, 0x44, 0xd1, 0x3c, 0xc1, 0x9f, 0xb8, 0xc7, 0x31, 0xb9, 0x2e, 0xfd, 0xae, 0x6b, 0x41, 0xc3, 0x22, 0x55, 0xc1, 0x16, 0xea, 0xe0, 0xc8, 0x1f, 0xcc, 0xbc, 0x1b, 0x43},
		{0x6, 0x24, 0xb5, 0x39, 0x6, 0xf5, 0xe, 0xf3, 0xba, 0xf4, 0x82, 0x63, 0x7e, 0x4c, 0x47, 0x14, 0x3c, 0xdf, 0xd6, 0x12, 0xf3, 0x1, 0xbc, 0x9d, 0xed, 0x44, 0x6e, 0x41, 0xb5, 0x62, 0xc6, 0x1f},
		{0x14, 0xf5, 0xa5, 0x48, 0x9, 0x54, 0xf2, 0xa8, 0x22, 0xe1, 0xcd, 0x4d, 0x5d, 0x13, 0x2e, 0x83, 0x3e, 0xf5, 0xeb, 0x75, 0xd5, 0x2, 0xfb, 0xbf, 0xe1, 0xc0, 0x76, 0x64, 0x4, 0x6, 0xd1, 0x2a},
		{0x0, 0xc5, 0x95, 0x11, 0xc0, 0xe3, 0xe8, 0xb4, 0x36, 0x2c, 0x57, 0xe, 0xbb, 0x3d, 0x60, 0xd0, 0xce, 0x57, 0x1e, 0x42, 0x76, 0xfa, 0x50, 0x90, 0x7e, 0x5d, 0xe4, 0xce, 0xbe, 0x47, 0x26, 0x54},
		{0xda, 0x70, 0xdc, 0xc2, 0xfd, 0xb, 0xe6, 0x30, 0xad, 0x74, 0x70, 0x32, 0xa0, 0x42, 0x39, 0x89, 0x95, 0x58, 0x9b, 0x73, 0xdb, 0x28, 0xbf, 0x93, 0x17, 0xf6, 0x22, 0x28, 0x29, 0xe, 0x57, 0x7b},
		{0x8, 0xe1, 0x56, 0xdc, 0x7d, 0x86, 0xaf, 0xb5, 0x3, 0xe2, 0xc7, 0xfc, 0x85, 0x1f, 0xac, 0x4e, 0xf3, 0xab, 0x8f, 0xac, 0x8d, 0x62, 0x88, 0x5e, 0xa1, 0xe2, 0xda, 0xd5, 0xb6, 0x40, 0xb4, 0x53},
		{0x26, 0xe2, 0x66, 0x3e, 0x7, 0xa5, 0x61, 0x55, 0x76, 0xab, 0x7f, 0xcf, 0x3a, 0x20, 0x68, 0x24, 0xb9, 0x6, 0xca, 0xc1, 0x16, 0x6c, 0x46, 0xa7, 0x6d, 0x9, 0x69, 0x5f, 0x15, 0xae, 0x13, 0x33},
		{0xea, 0xae, 0x22, 0x55, 0x34, 0x37, 0x36, 0xff, 0x6a, 0x1d, 0xd0, 0x0, 0x3c, 0x50, 0x4e, 0x58, 0xbc, 0xe4, 0xc6, 0x57, 0x6, 0x37, 0x4d, 0x91, 0xe0, 0x66, 0xbc, 0x41, 0x37, 0x75, 0x25, 0x11},
		{0x74, 0x54, 0x7e, 0x4e, 0x36, 0x9f, 0x55, 0x29, 0x54, 0x91, 0x40, 0x52, 0xc6, 0x59, 0x9f, 0x16, 0x7f, 0xd1, 0xb3, 0xdf, 0xaa, 0xc5, 0x45, 0xf3, 0x76, 0x34, 0xcf, 0xfe, 0x25, 0x7, 0xcd, 0x3d},
		{0x4, 0x9f, 0xa, 0x4f, 0xcb, 0xe5, 0x14, 0x94, 0x83, 0xc5, 0x8, 0xb0, 0xa3, 0xe4, 0xd8, 0x69, 0xca, 0x60, 0x12, 0x6f, 0xbb, 0x10, 0x74, 0xf4, 0x44, 0x64, 0xa8, 0xb, 0x8a, 0x8, 0xd7, 0x32},
		{0x1c, 0xf6, 0xa0, 0x30, 0x0, 0xe4, 0xe, 0xcd, 0x7e, 0x79, 0xfa, 0x90, 0xea, 0xb2, 0x9, 0x83, 0xe7, 0xd6, 0xf7, 0x8e, 0xf3, 0x81, 0x66, 0xb2, 0x9b, 0x6, 0xfd, 0xca, 0xed, 0x8c, 0x51, 0x70},
		{0xcc, 0xf0, 0x78, 0x10, 0x22, 0x87, 0xfb, 0x24, 0x2, 0x3b, 0xe8, 0xcc, 0x5a, 0x48, 0x85, 0xfc, 0xa9, 0x25, 0x9a, 0x5e, 0xbe, 0x5c, 0xed, 0xb1, 0x23, 0xe7, 0x39, 0x74, 0xcf, 0x43, 0x26, 0x16},
		{0x3c, 0xcf, 0x90, 0x67, 0x2f, 0x5e, 0xed, 0x45, 0x6c, 0xe7, 0x4f, 0xa8, 0x58, 0xd1, 0xfa, 0x9a, 0xc5, 0x87, 0xc, 0x59, 0x93, 0xd1, 0x21, 0xd1, 0x2f, 0x9f, 0xa2, 0x80, 0xa1, 0x50, 0xfa, 0x62},
		{0x70, 0x93, 0xcf, 0xeb, 0x9a, 0xe3, 0x26, 0xf6, 0x61, 0x3e, 0xd9, 0x8a, 0x78, 0x3, 0xd2, 0x93, 0x38, 0x44, 0x64, 0x24, 0xa3, 0xe1, 0x36, 0xc8, 0xa6, 0x73, 0x30, 0x68, 0x2, 0xc8, 0xe6, 0x11},
	}
	WorkBase = [][]byte{
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6},

		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xd},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x13},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x14},

		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x15},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x16},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x17},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x18},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x19},
		{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1a},
	}
)

func Init() {
	for i := 0; i < 20; i++ {
		LastStakeInfo[common.Bytes2Hex(WorkBase[i])] = Coinbase[i]
	}

	for i := 6; i < 26; i++ {
		StakeInfo20 = append(StakeInfo20, &substrate.StakeInfo{
			Coinbase:      [32]byte{},
			WorkBase:      WorkBase[i],
			IsWork:        true,
			LockedBalance: types.NewU128(*big.NewInt(int64(i))),
			WorkCount:     0,
		})
		cb := [32]byte{}
		if i < 20 {
			cb = Coinbase[i]
		}
		WantStakeInfo = append(WantStakeInfo, &substrate.StakeInfo{
			Coinbase:      cb,
			WorkBase:      WorkBase[i],
			IsWork:        true,
			LockedBalance: types.NewU128(*big.NewInt(int64(i))),
			WorkCount:     0,
		})
	}
}

func TestRLPEncodeAndDecode(t *testing.T) {
	type StakeInfo struct {
		Coinbase      [32]byte
		WorkBase      []byte
		IsWork        bool
		LockedBalance types.U128
		WorkCount     uint32
	}
	bob, _ := types.NewAddressFromHexAccountID("0x8eaf04151687736326c9fea17e25fc5287613693c912909cb226aa4794f26a48")
	var infos = StakeInfo{
		Coinbase:      bob.AsAccountID,
		WorkBase:      bob.AsAccountID[:],
		IsWork:        true,
		LockedBalance: types.NewU128(*big.NewInt(8888)),
		WorkCount:     0,
	}

	data, err := rlp.EncodeToBytes(infos)
	if err != nil {
		t.Fatal(err)
	}
	if err := ioutil.WriteFile("/Users/t/Library/NuLinkWatcher/stake-info.rlp", data, 0664); err != nil {
		t.Fatal(err)
	}

	file, err := ioutil.ReadFile("/Users/t/Library/NuLinkWatcher/stake-info.rlp")
	if err != nil {
		t.Fatal(err)
	}
	if len(file) == 0 {
		t.Log("file is empty...")
		return
	}

	var si StakeInfo
	if err := rlp.DecodeBytes(file, &si); err != nil {
		t.Fatal(err)
	}
	t.Logf("============================== si: %+v\n", si)
}

func TestTestRLPDecode(t *testing.T) {
	type StakeInfo struct {
		Coinbase      [32]byte
		WorkBase      []byte
		IsWork        bool
		LockedBalance types.U128
		WorkCount     uint32
	}

	file, err := ioutil.ReadFile("./stake-info.rlp")
	if err != nil {
		t.Fatal(err)
	}
	if len(file) == 0 {
		t.Log("file is empty...")
		return
	}

	var si StakeInfo
	if err := rlp.DecodeBytes(file, &si); err != nil {
		t.Fatal(err)
	}
	t.Logf("============================== si: %+v\n", si)
}

func TestNewAccountIDFromPublicKey(t *testing.T) {
	PublicKeys := []string{
		"d0e38319ea54a336f829da6cb91e11806c3474c354a5c05476b76ea97d6db414",
		"148256643071d03055fd90827acd29333b08a044d34b33e0c6e25ac5fc32254f",
		"244117f063187a04f5e6fc92d2f2a8f5c5262df8d8e6a485059e2ce917388143",
		"54eeb9e49c0f938573574b1449042457dcf09e75b05ead429aa446d69b4aff59",
		"94ac09777720191d2c859d72af24e37235cb4affbc1eee570cc308214a754118",
		"78b0d1876eeb0e1701e11b74b5ddd5c6bfc1852ae55e07aaa36a788b10aabb10",
		"d4a83e5fbf44d13cc19fb8c731b92efdae6b41c32255c116eae0c81fccbc1b43",
		"0624b53906f50ef3baf482637e4c47143cdfd612f301bc9ded446e41b562c61f",
		"14f5a5480954f2a822e1cd4d5d132e833ef5eb75d502fbbfe1c076640406d12a",
		"00c59511c0e3e8b4362c570ebb3d60d0ce571e4276fa50907e5de4cebe472654",
		"da70dcc2fd0be630ad747032a042398995589b73db28bf9317f62228290e577b",
		"08e156dc7d86afb503e2c7fc851fac4ef3ab8fac8d62885ea1e2dad5b640b453",
		"26e2663e07a5615576ab7fcf3a206824b906cac1166c46a76d09695f15ae1333",
		"eaae2255343736ff6a1dd0003c504e58bce4c65706374d91e066bc4137752511",
		"74547e4e369f552954914052c6599f167fd1b3dfaac545f37634cffe2507cd3d",
		"049f0a4fcbe5149483c508b0a3e4d869ca60126fbb1074f44464a80b8a08d732",
		"1cf6a03000e40ecd7e79fa90eab20983e7d6f78ef38166b29b06fdcaed8c5170",
		"ccf078102287fb24023be8cc5a4885fca9259a5ebe5cedb123e73974cf432616",
		"3ccf90672f5eed456ce74fa858d1fa9ac5870c5993d121d12f9fa280a150fa62",
		"7093cfeb9ae326f6613ed98a7803d29338446424a3e136c8a673306802c8e611",
	}
	//Coinbase := make([]types.AccountID, 0, 20)
	for _, pk := range PublicKeys {
		bs, err := hex.DecodeString(pk)
		if err != nil {
			panic(err)
		}
		accountID := types.NewAccountID(bs)
		//Coinbase = append(Coinbase, accountID)
		fmt.Printf("%#v: {},\n", accountID)
	}
}

func TestBigToAddress(t *testing.T) {
	for i := int64(1); i <= 20; i++ {
		addr := common.BigToAddress(big.NewInt(i))
		fmt.Printf("%#v,\n", addr[:])
	}
}

func TestAssignCoinbase(t *testing.T) {
	Init()

	type args struct {
		top20StakeInfos substrate.StakeInfos
		lastInfos       map[string][32]byte
	}
	tests := []struct {
		name string
		args args
		want substrate.StakeInfos
	}{
		{
			name: "",
			args: args{
				top20StakeInfos: StakeInfo20,
				lastInfos:       LastStakeInfo,
			},
			want: WantStakeInfo,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			//for c, w := range LastStakeInfo {
			//	fmt.Printf("%#v:%#v\n", common.Hex2Bytes(c), w)
			//}
			//fmt.Printf("\n\n\n")
			////
			//for _, info := range StakeInfo20 {
			//	fmt.Printf("%#v\n", info)
			//}
			//fmt.Printf("\n\n\n")

			if got := AssignCoinbase(tt.args.top20StakeInfos, tt.args.lastInfos); !reflect.DeepEqual(got[:14], tt.want[:14]) {
				t.Errorf("AssignCoinbase() = %v, want %v", got[:14], tt.want[:14])
				for _, info := range got[:14] {
					fmt.Printf("%#v\n", info)
				}

				fmt.Printf("\n\n\n")

				for _, info := range tt.want[:14] {
					fmt.Printf("%#v\n", info)
				}
			}
		})
	}
}

func TestWriteAndReadStakeInfo(t *testing.T) {
	filePath := "./stake-info.json"
	stakeInfos := substrate.StakeInfos{
		{
			Coinbase:      Coinbase[4],
			WorkBase:      WorkBase[4],
			IsWork:        true,
			LockedBalance: types.NewU128(*big.NewInt(5)),
			WorkCount:     1,
		},
		{
			Coinbase:      Coinbase[3],
			WorkBase:      WorkBase[3],
			IsWork:        true,
			LockedBalance: types.NewU128(*big.NewInt(4)),
			WorkCount:     1,
		},
		{
			Coinbase:      Coinbase[2],
			WorkBase:      WorkBase[2],
			IsWork:        true,
			LockedBalance: types.NewU128(*big.NewInt(3)),
			WorkCount:     1,
		},
		{
			Coinbase:      Coinbase[1],
			WorkBase:      WorkBase[1],
			IsWork:        true,
			LockedBalance: types.NewU128(*big.NewInt(2)),
			WorkCount:     1,
		},
		{
			Coinbase:      Coinbase[0],
			WorkBase:      WorkBase[0],
			IsWork:        true,
			LockedBalance: types.NewU128(*big.NewInt(1)),
			WorkCount:     1,
		},
	}

	want := map[string][32]byte{
		common.Bytes2Hex(WorkBase[4]): Coinbase[4],
		common.Bytes2Hex(WorkBase[3]): Coinbase[3],
		common.Bytes2Hex(WorkBase[2]): Coinbase[2],
		common.Bytes2Hex(WorkBase[1]): Coinbase[1],
		common.Bytes2Hex(WorkBase[0]): Coinbase[0],
	}

	if err := WriteStakeInfos(filePath, stakeInfos); err != nil {
		t.Fatal(err)
	}

	got, err := ReadStakeInfos(filePath)
	if err != nil {
		t.Fatal(err)
	}
	if !reflect.DeepEqual(got, want) {
		t.Errorf("ReadStakeInfos() = %v, want %v", got, want)
	}

}
